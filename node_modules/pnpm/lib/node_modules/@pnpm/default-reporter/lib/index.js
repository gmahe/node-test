"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const createDiffer = require("ansi-diff");
const cliCursor = require("cli-cursor");
const most = require("most");
const PushStream = require("zen-push");
const constants_1 = require("./constants");
const mergeOutputs_1 = require("./mergeOutputs");
const reporterForClient_1 = require("./reporterForClient");
const reporterForServer_1 = require("./reporterForServer");
function default_1(opts) {
    if (opts.context.argv[0] === 'server') {
        const log$ = most.fromEvent('data', opts.streamParser);
        reporterForServer_1.default(log$);
        return;
    }
    const outputMaxWidth = opts.reportingOptions && opts.reportingOptions.outputMaxWidth || process.stdout.columns && process.stdout.columns - 2 || 80;
    const output$ = toOutput$(Object.assign({}, opts, { reportingOptions: Object.assign({}, opts.reportingOptions, { outputMaxWidth }) }));
    if (opts.reportingOptions && opts.reportingOptions.appendOnly) {
        output$
            .subscribe({
            complete() { },
            error: (err) => console.error(err.message),
            next: (line) => console.log(line),
        });
        return;
    }
    cliCursor.hide();
    const diff = createDiffer({
        height: process.stdout.rows,
        outputMaxWidth,
    });
    output$
        .subscribe({
        complete() { },
        error: (err) => logUpdate(err.message),
        next: logUpdate,
    });
    function logUpdate(view) {
        process.stdout.write(diff.update(`${view}${constants_1.EOL}`));
    }
}
exports.default = default_1;
function toOutput$(opts) {
    opts = opts || {};
    const progressPushStream = new PushStream();
    const stagePushStream = new PushStream();
    const deprecationPushStream = new PushStream();
    const summaryPushStream = new PushStream();
    const lifecyclePushStream = new PushStream();
    const statsPushStream = new PushStream();
    const installCheckPushStream = new PushStream();
    const registryPushStream = new PushStream();
    const rootPushStream = new PushStream();
    const packageJsonPushStream = new PushStream();
    const linkPushStream = new PushStream();
    const cliPushStream = new PushStream();
    const otherPushStream = new PushStream();
    const hookPushStream = new PushStream();
    const skippedOptionalDependencyPushStream = new PushStream();
    const scopePushStream = new PushStream();
    setTimeout(() => {
        opts.streamParser['on']('data', (log) => {
            switch (log.name) {
                case 'pnpm:progress':
                    progressPushStream.next(log);
                    break;
                case 'pnpm:stage':
                    stagePushStream.next(log);
                    break;
                case 'pnpm:deprecation':
                    deprecationPushStream.next(log);
                    break;
                case 'pnpm:summary':
                    summaryPushStream.next(log);
                    break;
                case 'pnpm:lifecycle':
                    lifecyclePushStream.next(log);
                    break;
                case 'pnpm:stats':
                    statsPushStream.next(log);
                    break;
                case 'pnpm:install-check':
                    installCheckPushStream.next(log);
                    break;
                case 'pnpm:registry':
                    registryPushStream.next(log);
                    break;
                case 'pnpm:root':
                    rootPushStream.next(log);
                    break;
                case 'pnpm:package-json':
                    packageJsonPushStream.next(log);
                    break;
                case 'pnpm:link':
                    linkPushStream.next(log);
                    break;
                case 'pnpm:cli':
                    cliPushStream.next(log);
                    break;
                case 'pnpm:hook':
                    hookPushStream.next(log);
                    break;
                case 'pnpm:skipped-optional-dependency':
                    skippedOptionalDependencyPushStream.next(log);
                    break;
                case 'pnpm:scope':
                    scopePushStream.next(log);
                    break;
                case 'pnpm': // tslint:disable-line
                case 'pnpm:store': // tslint:disable-line
                case 'pnpm:shrinkwrap': // tslint:disable-line
                    otherPushStream.next(log);
                    break;
            }
        });
    }, 0);
    const log$ = {
        cli: most.from(cliPushStream.observable),
        deprecation: most.from(deprecationPushStream.observable),
        hook: most.from(hookPushStream.observable),
        installCheck: most.from(installCheckPushStream.observable),
        lifecycle: most.from(lifecyclePushStream.observable),
        link: most.from(linkPushStream.observable),
        other: most.from(otherPushStream.observable),
        packageJson: most.from(packageJsonPushStream.observable),
        progress: most.from(progressPushStream.observable),
        registry: most.from(registryPushStream.observable),
        root: most.from(rootPushStream.observable),
        scope: most.from(scopePushStream.observable),
        skippedOptionalDependency: most.from(skippedOptionalDependencyPushStream.observable),
        stage: most.from(stagePushStream.observable),
        stats: most.from(statsPushStream.observable),
        summary: most.from(summaryPushStream.observable),
    };
    const outputs = reporterForClient_1.default(log$, {
        appendOnly: opts.reportingOptions && opts.reportingOptions.appendOnly,
        cmd: opts.context.argv[0],
        isRecursive: opts.context.argv[0] === 'recursive',
        pnpmConfigs: opts.context.configs,
        subCmd: opts.context.argv[1],
        throttleProgress: opts.reportingOptions && opts.reportingOptions.throttleProgress,
        width: opts.reportingOptions && opts.reportingOptions.outputMaxWidth,
    });
    if (opts.reportingOptions && opts.reportingOptions.appendOnly) {
        return most.join(most.mergeArray(outputs)
            .map((log) => log.map((msg) => msg.msg)));
    }
    return mergeOutputs_1.default(outputs).multicast();
}
exports.toOutput$ = toOutput$;
//# sourceMappingURL=index.js.map